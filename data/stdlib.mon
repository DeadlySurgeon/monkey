//
// This file contains functions available by default, implemented in 100%
// pure monkey.
//
// i.e. This is part of our standard-library.
//
// If you wish to make changes to the standard-library functions defined
// here you'll need to rebuild `static.go` after editing this file, as
// that contains the embedded copy of this code which is included in
// the generated monkey-interpreter.
//
// To rebuild `static.go` use the `implant` tool.
//
// If you don't already have `implant` installed fetch it like so:
//
//     go get -u  github.com/skx/implant/
//
// Now regenerate the embedded version of this file and rebuild the
// interpreter with your changes:
//
//    implant -input data/ -output static.go
//    go build .
//


//
// Mathematical constants
//
const PI = 3.141592653589793;
const E  =  2.718281828459045;

//
// Constants referring to file-handles, as used for STDIN, STDOUT, STDERR
//
const STDIN  = 0;
const STDOUT = 1;
const STDERR = 2;


//
// First element of an array
//
function first( array ) {
  return( array[0] );
}


//
// The rest of an array - i.e. all elements EXCEPT the first
//
function rest( array ) {
  let result = [];

  if ( len(array) > 1 ) {
    let i = 1;
    for( i < len(a) ) {
      result = push(result, array[i]);
      i++;
    }
   }
   return result;
}


//
// Last element of an array
//
function last( array ) {
  if ( len( array ) > 0 ) {
    return(array[len(array)-1]);
  }

  // `return null` is implicit here.
}



//
// Is the given array empty?
//
function array.empty?() {
   if ( len(self) == 0 ) {
      return true;
   }
   return false;
}


//
// Call the given function on each entry, and return an array of the
// items for which the predicate returned true.
//
function array.filter( predicate ) {
   let i = 0;
   let l = len(self);
   let result = [];

   for( i < l ) {
      let entry = self[i];
      if (predicate(entry)) {
         let result = push( result, entry );
      }
      i++;
   }

   return result;
}


//
// Return the offset, if any, of the specified item in the array.
//
function array.find(item) {
   let i = 0;
   let l = len(self);

   for( i < l ) {
     if ( self[i] == item ) {
       return i;
     }
     i++;
   }

   // not found.
   return -1;
};


//
// Join the elements of an array by the given string.
//
function array.join( char ) {
   let r = "";
   let i = 0;
   let l = len(self);

   // For each entry.
   for( i < l ) {

     // If the result is non-empty add the separator.
     if ( len(r) > 0 ) {
       r+= char;
     }

     // add on the next element.
     r += string(self[i])
     i++;
   }

   return r;
}


//
// Return an array containing the result of applying the specified
// function to each element in the array.
//
function array.map( fnc ) {
   let i = 0;
   let l = len(self);
   let result = [];

   for( i < l ) {
      let tmp = fnc(self[i]);
      let result = push( result, tmp);
      i++;
   }

   return result;
}


//
// Reverse an array.
//
function array.reverse() {
  let r = [];
  let l = len(self);

  for( l > 0 ) {
     let r = push( r, self[l-1] );
     l--;
  }
  return r;
}


//
// sorted? returns true if the specified array is sorted.
//
function array.sorted?() {
  let i = 1;
  let l = len(self);

  // Array of zero/one element is always sorted.
  if ( l < 2 ) {
    return true;
  }

  // If a later item is smaller than the
  // earlier item the array is not sorted.
  for( i < l ) {
     if ( self[i] < self[i-1]) {
       return false;
     }
     i++;
  }

  return true;
}


//
// Swap the value of two array indexes.
//
// This is used by our sorting function.  Currently it isn't possible
// to mutate an array-member in-place.  So we create a new array
// correctly swapping the values at the given index.
//
// This would be easier if we had "elseif" support, or even a case
// statement.  (Due to the nested if usage here.)
//
function array.swap( a, b ) {
  let aVal = self[b];
  let bVal = self[a];

  let r = [];
  let i = 0;
  let l = len(self);

  for( i < l ) {
     if ( i == a ) {
        let r = push(r, aVal);
     } else {
        if ( i == b ) {
           let r = push(r,bVal );
        } else {
           let r = push( r, self[i] );
        }
     }
     i++;
  }

  return r;
}


//
// Sort the given array.
//
// This is grossly inefficient, obviously.
//
function array.sort() {

  // While the given array isn't sorted.
  for( ! self.sorted?() ) {

     // make a pass over the array.
     let i = 1;
     let l = len(self);
     for( i < l ) {

        // if this element is wrong swap it.
        if ( self[i] < self[i-1] ) {
          self = self.swap( i-1, i);
        }
        i++;
     }
  }

  // Should be done now.
  return self;
}



//
// Convert a float to an integer.
//
// Like Go we discard the value after the period, so 4.9 will become 4.
//
function float.to_i() {
   return( int( self ) );
}


//
// Is the given hash empty?
//
function hash.empty?() {
   if ( len(self.keys()) == 0 ) {
      return true;
   }
   return false;
}


//
// Convert an integer to a float.
//
function integer.to_f() {
   return( self + 0.0);
}


//
// Remove leading whitespace from the string.
//
function string.ltrim() {
   let reg = "^(\\s+)(.*)$";
   let out = match(reg, self);

   if ( out ) {
      return( out[1]) ;
   } else {
      return self;
   }
}


//
// Reverse a string,
//
function string.reverse() {
  let r= "";
  let l = len(self);

  for( l > 0 ) {
     r += self[l-1];
     l--;
  }
  return r;
}


//
// Remove trailing whitespace from the string.
//
function string.rtrim() {
   let reg = "^(.*?)(\\s*)$";
   let out = match(reg, self);

   if ( out ) {
      return( out[0]) ;
   } else {
      return self;
   }
}


//
// Trim leading & trailing whitespace from the given string.
//
function string.trim() {
   let l = self.ltrim();
   return( l.rtrim() );
}


//
// Convert the given string to lower-case.
//
function string.tolower() {
   let i = 0;
   let l = len(self);
   let r = "";

   for( i < l ) {
      let c = self[i];

      if ( c >= "A" && c <= "Z" ) {
           let c = c.ord();
           c += 32;
           c = c.chr();
      }
      i++;

      r += c;
   }

   return r;
}


//
// Convert the given string to upper-case.
//
function string.toupper() {
   let i = 0;
   let l = len(self);
   let r = "";

   for( i < l ) {
      let c = self[i];

      if ( c >= "a" && c <= "z" ) {
           let c = c.ord();
           c -= 32;
           c = c.chr();
      }
      i++;

      r += c;
   }

   return r;
}