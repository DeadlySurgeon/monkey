# 前言

首先第一句话要说的应该是“解释器是具有魔法的”， 一个不愿意透露姓名的早期阅读者说道：”这听上去好像有点傻“。但是我并没有这样认为，我始终坚持解释器非常有魔力。让我一点点告诉你为什么。

表面上来看，解释器看上去误以为很简单：文本写入，得到一些东西出来。他们就是一个程序把其他的程序代码作为输入，并且生成一些东西。是不是很简单， 对吗？但是你越考虑这个问题，你就越觉得这个更加迷人。看上去随机的字符，包括字母、数字或者特殊的符号被输送到解释器后就变得有意义，这些都是解释器赋予的意义。它从无意义中发现意义，电脑只是一个建立在只能理解0和1上的机器，但是却能够理解我们输送的字符并且做出相应的操作，这些都是解释器在读取的过程中进行的翻译。

我曾经不停的问自己：解释器到底是如何工作的？当问题第一次在我脑海中形成的时候，我已近知道只有我自己写一个解释器我才能明白问题的答案。所以我就开始着手进行这件事。

有好多书籍、文章、博客或者教程是关于解释器，但是它们绝大多数涉及两个风格中的其中一个。一是涉及的主题非常宏大，难以置信的理论知识，面向那些已经非常理解这些主题的读者；另外就是非常简短，仅仅提供了简单的介绍，将外部工作当做一个黑盒子并且以玩具版的解释器为关心的重点。

其中一个基础来源就是本书后面的资源，因为解释器仅仅说明了语法简的解释型编程语言。 我并不想走捷径，我确实想知道解释器如何工作的并且理解词法分析器和句法解析器是如何工作的。尤其是类C一样带花括号和分号的编程语言，当我还不知道如何开始解析它们，那些学术上的书籍包含着我要寻找的答案。当然对我来说从哪些冗长的，理论化解释和数学符号中，我很难得到我想要的答案。

我想要的东西是介于一个900页的关于编译器的书和用50行ruby代码写一个Lisp解释器的博客之间的内容。

为了你也包括我，写了这本书。我希望这本书是为了那些喜欢一探究竟的人，亦或者是那些喜欢通过了解一些如何工作的而学习的人。

在这本书中我们将从零开始为我们自己的编程语言写一本解释器。我们将不会使用任何第三方的工作或者库。这些将不会再生产实际中使用，也不会对性能测试上做一些工作。当然，这个解释器支持的编程语言会缺失一些功能，但是我们能够从中学到很多。

由于解释器中的种类繁多并且没有很相像，所以用通用的语句描述解释器非常困难。我们能够说的就是它们共有的基础属性就是读取源代码并且计算它，没有产生一些后续执行的可视化、即可结果。编译器确实恰恰相关的，它读取源代码并且生成背后机器理解的其他代码。

有些解释器非常短小简单，甚至没有涉及解析的的步骤。它们仅仅是立马解析输入，看看类似Brainfuck中的一个就明白我说的意思。

在其他精心设计的解释器中，包含了大量高度优化和使用了先进的解析和计算技术。其中一些不去计算其中的输入，将其中编译成叫做字节码的中间表达代码，然后计算这些字节码。更先进的就是叫做JIT解释器，它将输入编译成本地机器码，然后执行。

但是，在上述表示的两种类别中，有一种解释器能够解析源代码，然后构建一颗抽象语法树(AST)然后计算这棵树。这种类型的解释器有时叫做"tree-walking"解释器，因为它就像在抽象语法树上行走然后解释它。

在这本书中，我们将构建一个"tree-walking"解释器。

我们将会构建我们的词法解析器，语法解析器，树表达式和最后的计算器。我们将会看到什么是token, 什么是抽象语法树，如何去构建这一颗树，如何计算这个树和如何去拓展我们的编程语言和一些内置函数。
